# Диаграмма компонентов для мобильного приложения туристов

![image](https://github.com/miamib34ch/HSE-SoftwareArchitecture/assets/77894393/da7a70c0-beb5-4b1e-89eb-9ae8ca3b23a8)

# Диаграмма последовательности

![image](https://github.com/miamib34ch/HSE-SoftwareArchitecture/assets/77894393/11298299-325b-4aa8-8794-736101583364)

Краткие пояснения к предоставленной диаграмме последовательности:

1. **Открытие приложения:**  
   - Турист открывает мобильное приложение
  
2. **Просмотр маршрута:**
   - Турист запрашивает просмотр маршрута на `Карта`
   - `Карта` отправляет запрос на данные маршрута
   - `ViewModel` запрашивает данные маршрута у `Model`
   - `Model` обращается к серверу `Сервер` для получения данных маршрута
   - `Сервер` возвращает данные маршрута `Model`
   - `Model` передает данные маршрута `ViewModel`
   - `ViewModel` передает данные маршрута `Карта`, которое отображает маршрут для туриста

3. **Выбор маршрута и загрузка материалов:**
   - Турист выбирает точку маршрута
   - `Карта` отправляет запрос на текстовые и медиа материалы для выбранного маршрута `ViewModel`
   - `ViewModel` передает запрос на материалы `Model`
   - `Model` обращается к серверу (`Сервер`) для получения материалов
   - `Сервер` возвращает материалы `Model`
   - `Model` передает материалы `ViewModel`
   - `ViewModel` передает материалы `Карта`, которое отображает материалы для выбранной точки

4. **Просмотр дополненной реальности (AR):**
   - Турист переходит к просмотру дополненной реальности
   - Компонент AR (`Дополненная реальность`) запрашивает данные AR, отправляет запрос данных AR `ViewModel`
   - `ViewModel` передает запрос данных AR `Model`
   - `Model` обращается к серверу (`Сервер`) для получения данных AR
   - `Сервер` возвращает данные AR `Model`
   - `Model` передает данные AR `ViewModel`
   - `ViewModel` передает данные AR компоненту AR (`Дополненная реальность`), который отображает дополненную реальность для туриста

5. **Закрытие приложения:**  
   - Турист закрывает мобильное приложение
   
Данная диаграмма демонстрирует взаимодействие между актором (Туристом), контейнером `Клиент туристов`: компонентами `Карта`, `ViewModel`, `Model`, `Дополненная реальность`; контейнером `Сервер` при различных сценариях использования, отражая общий поток данных и запросов в системе.

# Модель базы данных

![image](https://github.com/miamib34ch/HSE-SoftwareArchitecture/assets/77894393/5fcc1a1f-7473-421c-9280-f9b7dda032ab)

Краткое пояснение к модели базы данных:

1. **`User` (Пользователь):**
   - Учетная запись пользователя системы.
   - Может создавать маршруты и связан с маршрутами, которые он создал, если isTurist == false.
2. **`Route` (Маршрут):**
   - Представляет маршрут в системе, который создан пользователем (`User`), у которого isTurist == false.
   - Содержит точки интереса и ссылку на маршрут.
   - Ассоциирован с пользователем, который создал маршрут.
3. **`PointOfInterest` (Точка интереса):**
   - Описывает ключевые места внутри маршрута.
   - Связана с материалами и AR-компонентой.
   - Содержит координаты места.
   - Принадлежит определенному маршруту.
4. **`Material` (Материал):**
   - Представляет собой контент, связанный с точками интереса.
   - Может быть текстом, изображением или видео.
   - Хранится путь на сервере до материала.
   - Привязан к точке интереса.
5. **`ARComponent` (AR-компонента):**
   - Содержит данные для расположения в пространстве в контексте дополненной реальности (AR).
   - Связана с точками интереса.

# Код с учетом принципов KISS, YAGNI, DRY и SOLID.

   ```Swift

   protocol Service {
      associatedtype T
    
      func fetchData(id: Any, completion: @escaping (T?, Error?) -> Void)
   }
   
   class RouteService: Service {
      typealias T = [Route]
    
      func fetchData(id: String, completion: @escaping ([Route]?, Error?) -> Void) {
         // Логика получения маршрутов из сети или хранилища данных
         // ...
        
         // В случае успеха
         completion(routes, nil)
        
         // В случае ошибки
         completion(nil, error)
      }
   }

   class PointOfInterestService: Service {
      typealias T = [PointOfInterest]
    
      func fetchData(id: Int, completion: @escaping ([PointOfInterest]?, Error?) -> Void) {
         // Логика получения точек интереса для конкретного маршрута
         // ...
        
         // В случае успеха
         completion(pointsOfInterest, nil)
        
         // В случае ошибки
         completion(nil, error)
      }
   }

   class MainViewControler: UIViewController {
   
      var service: Service = RouteService()
      let link = "http://url.com/route"
      let routeId = 123

      // Получение маршрутов
      service.fetchData(id: link) { (routes, error) in
         if let routes = routes {
           // Обработка маршрутов
         } else if let error = error {
           // Обработка ошибки
         }
      }
   
      service = PointOfInterestService()

      // Получение точек интереса для конкретного маршрута
      pointOfInterestService.fetchData(routeId: routeId) { (pointsOfInterest, error) in
         if let pointsOfInterest = pointsOfInterest {
            // Обработка точек интереса
         } else if let error = error {
            // Обработка ошибки
         }
      }
   }
   ```
   * **Принцип KISS (Keep It Simple, Stupid):**  
     Классы `RouteService` и `PointOfInterestService` предоставляют простые методы для получения маршрутов и точек интереса соответственно. Они скрывают сложность внутренней реализации, обеспечивая клиентскому коду простоту взаимодействия (строки 121 и 132 этого .md файла).
   * **Принцип единственной ответственности (SOLID):**  
      * S: Каждый из этих классов имеет одну основную ответственность - предоставление данных о маршрутах или точках интереса. Это облегчает поддержку, расширение и изменение кода.
      * O: Используем протокол `Service`, который позволяет добавлять новые переменные и методы, не изменяя существующий код.
      * L: Наследование не используется, не продемонстровано. Swift, на котором пишу код, больше не про ООП, а протокольно-ориентированный. 
      * I: В данном коде нет классов-клиентов, которые нереализовывали бы какие-либо методы протоколов. Все протоколы содержат лишь необходимые методы.
      * D: Создаём объект типа `Service` и можем ему подсовывать любые сервисы, выполняющие этот проткол.
   * **Принцип DRY (Don't Repeat Yourself):**  
     Логика обработки ответа от сервисов вынесена в замыкания обработчиков (`completion`), что позволяет избежать повторения кода при обработке результатов.
   * **Принцип YAGNI (You Aren't Gonna Need It):**  
     Реализована только минимально необходимая функциональность для получения маршрутов и точек интереса. Ненужные функции или избыточные детали отсутствуют. Например, не стали реализовывать удаление маршрутов, сейчас это не требуется и в постановке про это не сказано.

# Другие принципы разработки: 

## BDUF - Big design up front (Масштабное проектирование прежде всего)

**Применимость:** BDUF может быть полезным в случаях, когда требования к проекту хорошо определены и изменения маловероятны. Это позволяет учесть все детали проектирования на ранних этапах и избежать больших изменений в ходе разработки.

**Отказ:** В современной среде разработки, где требования могут меняться, гибкие методологии более предпочтительны. BDUF может быть избыточным и затруднить адаптацию к изменениям, особенно в долгосрочных проектах.

**Проект:** Поскольку диплом разрабатывается по методологии водопада, то данный принцип может хорошо подойти. 

## SoC - Separation оf concerns (Принцип разделения ответственности)

**Применимость:** Принцип SoC содействует легкости поддержки, повторному использованию кода и тестированию. Разделение кода на логические компоненты с определенными обязанностями облегчает понимание кода и его модификацию.

**Отказ:** В некоторых случаях (например, в простых проектах) чрезмерное разделение может привести к избыточности кода и усложнению проекта без необходимости.

**Проект:** В целом можно сказать, что он уже используется, поскольку похож на S из SOLID.

## MVP - Minimum viable product (Минимально жизнеспособный продукт)

**Применимость:** Использование MVP позволяет быстро внедрить базовую функциональность продукта и получить обратную связь от пользователей. Это позволяет лучше понять требования и улучшить продукт на ранних этапах.

**Отказ:** В некоторых ситуациях (например, в проектах с высоким техническим риском) может потребоваться более детальное прототипирование или анализ перед разработкой MVP.

**Проект:** В рамках ограниченности времени (диплом привязан к графику учебного процесса) может быть применён.

## PoC - Proof of concept (Доказательство концепции)

**Применимость:** PoC полезен, когда необходимо оценить техническую осуществимость или эффективность конкретной концепции перед тем, как начинать полноценную разработку.

**Отказ:** В некоторых ситуациях (например, когда требования к проекту хорошо известны) PoC может быть избыточным, и разработку стоит начинать сразу с основного проекта.

**Проект:** В рамках диплома избыточен, работаем по водопаду, требования хорошо изучены и известны + нет времени оценивать эффективность, из-за сжатых сроков.
